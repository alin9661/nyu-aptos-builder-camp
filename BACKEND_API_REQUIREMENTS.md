# Backend API Requirements for Wallet Integration

This document outlines the backend API endpoints required for the wallet frontend components to function properly.

## Required Endpoints

### 1. Get Wallet Info
**Endpoint:** `GET /api/auth/wallet-info`

**Headers:**
```
Authorization: Bearer {accessToken}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "wallet": {
      "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      "publicKey": "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
      "isAutoGenerated": true,
      "network": "testnet",
      "balance": "100000000",
      "createdAt": "2024-01-01T00:00:00.000Z"
    }
  }
}
```

**Error Response:**
```json
{
  "success": false,
  "error": "Wallet not found"
}
```

**Notes:**
- Should return wallet info for authenticated user
- Balance is in octas (1 APT = 100,000,000 octas)
- Must validate access token
- Should be called automatically after login

---

### 2. Get Wallet Balance
**Endpoint:** `GET /api/wallet/balance`

**Headers:**
```
Authorization: Bearer {accessToken}
```

**Query Parameters:**
- `address` (string, required): Wallet address

**Response:**
```json
{
  "success": true,
  "data": {
    "balance": "100000000"
  }
}
```

**Error Response:**
```json
{
  "success": false,
  "error": "Failed to fetch balance"
}
```

**Notes:**
- Queries Aptos blockchain for real-time balance
- Balance should be in octas
- Should cache result for ~30 seconds to reduce blockchain queries

---

### 3. Get Transaction History
**Endpoint:** `GET /api/wallet/transactions`

**Headers:**
```
Authorization: Bearer {accessToken}
```

**Query Parameters:**
- `address` (string, required): Wallet address
- `limit` (number, optional): Number of transactions to return (default: 50)

**Response:**
```json
{
  "success": true,
  "data": {
    "transactions": [
      {
        "hash": "0xabcd1234...",
        "type": "received",
        "amount": "50000000",
        "status": "confirmed",
        "timestamp": "2024-01-01T12:00:00.000Z",
        "from": "0xsender...",
        "to": "0xrecipient..."
      }
    ]
  }
}
```

**Error Response:**
```json
{
  "success": false,
  "error": "Failed to fetch transactions"
}
```

**Notes:**
- Queries Aptos blockchain for transaction history
- Should return both sent and received transactions
- Transactions sorted by timestamp (newest first)
- Should cache result for ~1 minute

---

### 4. Export Wallet Info
**Endpoint:** `GET /api/wallet/export`

**Headers:**
```
Authorization: Bearer {accessToken}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "export": {
      "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      "publicKey": "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
      "network": "testnet",
      "createdAt": "2024-01-01T00:00:00.000Z",
      "warning": "This export does NOT include your private keys. Your private keys are securely stored and encrypted on our servers."
    }
  }
}
```

**Error Response:**
```json
{
  "success": false,
  "error": "Failed to export wallet info"
}
```

**Notes:**
- Returns PUBLIC wallet information only
- Should NEVER include private keys
- Include security warning in response
- Used for backup/records purposes

---

## Database Schema

### Wallet Table
```sql
CREATE TABLE wallets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  address VARCHAR(66) NOT NULL UNIQUE, -- 0x + 64 hex chars
  public_key VARCHAR(66) NOT NULL,
  encrypted_private_key TEXT NOT NULL, -- AES-256-GCM encrypted
  encryption_iv TEXT NOT NULL, -- Initialization vector for decryption
  is_auto_generated BOOLEAN DEFAULT true,
  network VARCHAR(20) DEFAULT 'testnet',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  last_balance_check TIMESTAMP,
  cached_balance VARCHAR(50), -- Cache balance to reduce blockchain queries

  INDEX idx_user_id (user_id),
  INDEX idx_address (address)
);
```

## Security Requirements

### Authentication
- All endpoints MUST require valid JWT access token
- Token should be validated on every request
- Token should contain user_id claim

### Encryption
- Private keys MUST be encrypted with AES-256-GCM
- Use unique IV (initialization vector) for each key
- Store encryption key in secure environment variables
- Never log or expose private keys

### Rate Limiting
- Implement rate limiting on all endpoints
- Suggested limits:
  - `/api/auth/wallet-info`: 60 requests/minute
  - `/api/wallet/balance`: 30 requests/minute
  - `/api/wallet/transactions`: 30 requests/minute
  - `/api/wallet/export`: 10 requests/minute

### CORS
- Restrict CORS to allowed frontend domains
- Use credentials: true for cookies/auth

## Integration with Aptos Blockchain

### Aptos SDK Usage
```typescript
import { Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";

const config = new AptosConfig({
  network: Network.TESTNET
});
const aptos = new Aptos(config);

// Get balance
const balance = await aptos.getAccountResource({
  accountAddress: address,
  resourceType: "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>"
});

// Get transactions
const transactions = await aptos.getAccountTransactions({
  accountAddress: address,
  options: { limit: 50 }
});
```

### Network Configuration
- Use environment variable for network selection
- Support both testnet and mainnet
- Testnet: https://fullnode.testnet.aptoslabs.com/v1
- Mainnet: https://fullnode.mainnet.aptoslabs.com/v1

## Error Handling

### Standard Error Response Format
```json
{
  "success": false,
  "error": "Error message here",
  "code": "ERROR_CODE",
  "details": {} // Optional additional details
}
```

### Error Codes
- `WALLET_NOT_FOUND` - User doesn't have a wallet
- `INVALID_ADDRESS` - Invalid wallet address format
- `BLOCKCHAIN_ERROR` - Error querying Aptos blockchain
- `ENCRYPTION_ERROR` - Error encrypting/decrypting keys
- `UNAUTHORIZED` - Invalid or missing access token
- `RATE_LIMIT_EXCEEDED` - Too many requests

## Wallet Creation Process

When a new user signs up via NYU SSO:

1. Generate new Aptos keypair
2. Encrypt private key with AES-256-GCM
3. Store in database:
   - address
   - public_key
   - encrypted_private_key
   - encryption_iv
   - user_id
4. Return success response

**Implementation Reference:**
```typescript
import { Account, Ed25519PrivateKey } from "@aptos-labs/ts-sdk";
import crypto from "crypto";

// Generate new account
const account = Account.generate();

// Encrypt private key
const algorithm = 'aes-256-gcm';
const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
const iv = crypto.randomBytes(16);
const cipher = crypto.createCipheriv(algorithm, key, iv);

let encrypted = cipher.update(account.privateKey.toString(), 'utf8', 'hex');
encrypted += cipher.final('hex');
const authTag = cipher.getAuthTag().toString('hex');

// Store in database
await db.wallets.create({
  user_id: userId,
  address: account.accountAddress.toString(),
  public_key: account.publicKey.toString(),
  encrypted_private_key: encrypted + ':' + authTag,
  encryption_iv: iv.toString('hex'),
  is_auto_generated: true,
  network: 'testnet'
});
```

## Testing Checklist

### Unit Tests
- [ ] Wallet creation generates valid Aptos address
- [ ] Private key encryption/decryption works correctly
- [ ] Balance query returns valid format
- [ ] Transaction query handles pagination
- [ ] Export excludes private keys

### Integration Tests
- [ ] User can retrieve wallet info after login
- [ ] Balance updates from blockchain
- [ ] Transaction history loads correctly
- [ ] Rate limiting works as expected
- [ ] Error responses follow standard format

### Security Tests
- [ ] Cannot access other users' wallets
- [ ] Private keys are never exposed in responses
- [ ] Encrypted data cannot be decrypted without key
- [ ] Invalid tokens are rejected
- [ ] SQL injection attempts fail

## Monitoring & Logging

### Metrics to Track
- Wallet creation success rate
- API response times
- Blockchain query latency
- Cache hit rates
- Error rates by type

### Logs to Capture
- Wallet creation events
- Balance query attempts
- Transaction query attempts
- Failed decryption attempts (security concern)
- Rate limit violations

### Alerts to Set
- High error rate (>5%)
- Slow blockchain queries (>2s)
- Failed encryption/decryption
- Unusual wallet activity patterns

## Performance Optimization

### Caching Strategy
1. Cache wallet balance for 30 seconds
2. Cache transaction history for 1 minute
3. Use Redis for distributed caching
4. Invalidate cache on known transactions

### Database Optimization
1. Index on user_id and address
2. Partition table by created_at (if large dataset)
3. Use connection pooling
4. Optimize queries with EXPLAIN ANALYZE

### Blockchain Query Optimization
1. Use batch queries when possible
2. Implement request queuing to avoid rate limits
3. Use Aptos indexer API for historical data
4. Cache frequently accessed data

## Deployment Considerations

### Environment Variables Required
```env
# Encryption
ENCRYPTION_KEY=<256-bit hex key>

# Aptos Configuration
APTOS_NETWORK=testnet
APTOS_NODE_URL=https://fullnode.testnet.aptoslabs.com/v1

# Rate Limiting
RATE_LIMIT_WALLET_INFO=60
RATE_LIMIT_BALANCE=30
RATE_LIMIT_TRANSACTIONS=30
RATE_LIMIT_EXPORT=10

# Caching
REDIS_URL=redis://localhost:6379
CACHE_BALANCE_TTL=30
CACHE_TRANSACTIONS_TTL=60
```

### Health Check Endpoint
```
GET /api/health
```

**Response:**
```json
{
  "status": "healthy",
  "services": {
    "database": "connected",
    "redis": "connected",
    "aptos_node": "reachable"
  },
  "timestamp": "2024-01-01T00:00:00.000Z"
}
```

## Migration from Existing System

If migrating from existing wallet system:

1. Create migration script
2. Validate all existing addresses
3. Re-encrypt private keys with new key
4. Update database schema
5. Test with subset of users
6. Rollout gradually
7. Monitor for issues

## Support & Maintenance

### Regular Tasks
- Rotate encryption keys (quarterly)
- Update Aptos SDK (monthly)
- Review error logs (weekly)
- Optimize slow queries (as needed)
- Update documentation (as changed)

### Incident Response
1. Detect issue via monitoring
2. Check logs for root cause
3. Apply fix
4. Test thoroughly
5. Deploy to production
6. Monitor for recurrence

## Questions?

Contact the frontend team if:
- API contract needs changes
- New endpoints are required
- Response format is unclear
- Integration issues arise

---

**Last Updated:** November 11, 2025
**Status:** Ready for backend implementation
**Version:** 1.0.0
